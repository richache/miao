<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>画图</title>
  <style>
    canvas {
      border: 2px solid #f0f;
      display: block;
      margin: auto;
    }

  </style>
</head>

<body>
  <canvas width="1200" height="1200"></canvas>
</body>
<script>
  var canvas = document.querySelector('canvas')
  canvas.style.imageRendering = 'pixelated' //放大时的插帧方式：不插帧，直接放大像素
  var ctx = canvas.getContext('2d')

  function dot(x, y, color = 'black') {
    x = Math.trunc(x)
    y = Math.trunc(y)
    ctx.fillStyle = color
    ctx.fillRect(x, y, 1, 1)
  }
  /**
   * 你的任务：通过调用dot函数，实现：
   * 需要注意，dot函数不能接收浮点数，如果参数为浮点数，会被转换为整数后绘制
      * 在 坐标 (42, 42) 画出一个点
      * 画一条水平实线，粗细为一个像素
      * 画一条垂直实线，粗细为一个像素
      * 画一条一个实点一个空点的虚线
      * 画一条两个实点两个空点的虚线
      * 画一条三个实点两个空点的虚线
      * 画一条45度的斜线
      * 画一条30度的斜线（与x轴的夹角呈30度）
      * 画一条60度的斜线（与x轴的夹角呈60度）
      * 画一条跨越画布左上角和右下角的对角线
      * 画一个空心矩形
      * 画一个实心矩形
      * 画两个空心的圆，圆心在画布中心：
        * 一个半径为50像素
        * 一个半径为200像素
      * 画一个实心的圆，半径至少为100像素
      * 画一个【大小位置都合适】的sin(x)的图像

      * 画出rgb色彩空间的某一面（尺寸要大于100x100）
      * 如果做出上一题后，尝试将其每个点的坐标乘以一个矩阵（如(2,0,0,2)或(1,0.27得到新的位置，即绘制出被线性变换后的色彩空间某一面
        可以考虑如下几种矩阵：
           2 0
           0 2
           ------
           1  0.27
           0  1
           ------
           0.5    0.87
           -0.87  0.5

   */
</script>
<script>
  // 不可更改上面的代码
  // 你的代码写在这里

  // 画一个实心的圆，半径至少为100像素
  for (var y15 = -120; y15 <= 120; y15++) {
    for (var x15 = -120; x15 <= 120; x15++) {
      if (x15 * x15 + y15 * y15 < 10000) {
        dot(250 + x15, 200 + y15, "red")
      }
    }
  }

  // 在 坐标 (42, 42) 画出一个点
  var x1 = 42, y1 = 42
  dot(x1, y1, "blue")

  // 画一条水平实线，粗细为一个像素
  var y2 = 20
  for (var x2 = 100; x2 <= 400; x2++) {
    dot(x2, y2)
  }

  // 画一条垂直实线，粗细为一个像素
  var x3 = 20
  for (var y3 = 100; y3 <= 300; y3++) {
    dot(x3, y3)
  }

  // 画一条一个实点一个空点的虚线
  var y4 = 30
  for (x4 = 100; x4 <= 400; x4++) {
    if (x4 % 2 == 0) {
      dot(x4, y4)
    }
  }
  // 或者：
  var y4 = 35
  for (x4 = 100; x4 <= 400; x4 += 2) {
    dot(x4, y4)
  }

  // 画一条两个实点两个空点的虚线
  var y5 = 40, check = 0
  for (var x5 = 100; x5 <= 400; x5++) {
    check++
    if (check <= 2) {
      dot(x5, y5)
    } else if (check == 4) {
      check = 0
    }
  }

  // 画一条三个实点两个空点的虚线
  var y6 = 50, check = 0
  for (var x6 = 100; x6 <= 400; x6++) {
    check++
    if (check <= 3) {
      dot(x6, y6)
    } else if (check == 5) {
      check = 0
    }
  }
  //或者：
  for (var x6 = 100; x6 <= 400; x6++) {
    if (x6 % 5 < 3) {
      dot(x6, 55)
    }
  }

  // 画一条45度的斜线
  var x7 = 440, y7 = 62
  for (i = 1; i <= 50; i++) {
    dot(x7 + i, y7 + i)
  }

  // 画一条30度的斜线（与x轴的夹角呈30度）
  var y8 = 60
  for (var x8 = 440; x8 <= 490; x8++) {
    y8 += Math.sqrt(3) / 3
    dot(x8, y8, "purple")
  }

  // 画一条60度的斜线（与x轴的夹角呈60度）
  var y9 = 64
  for (var x9 = 440; x9 <= 490; x9++) {
    y9 += Math.sqrt(3)
    dot(x9, y9, "gold")
  }
  //或者：
  var x9 = 440
  for (var y9 = 80; y9 <= 150; y9++) {
    x9 += Math.sqrt(3) / 3
    dot(x9, y9, "aqua")
  }

  // 画一条跨越画布左上角和右下角的对角线
  var x10 = 0, y10 = 0
  while (x10 <= 1200) {
    dot(x10, y10)
    y10++
    x10++
  }

  // 画一个空心矩形
  for (var y11 = 70; y11 <= 100; y11++) {
    for (var x11 = 200; x11 <= 230; x11++) {
      if (x11 == 200 || x11 == 230 || y11 == 70 || y11 == 100) {
        dot(x11, y11, "brown")
      }
    }
  }

  // 画一个实心矩形
  for (var y12 = 100; y12 <= 150; y12++) {
    for (var x12 = 350; x12 <= 400; x12++) {
      dot(x12, y12, "orange")
    }
  }

  // 画两个空心的圆，圆心在画布中心：
  // * 一个半径为50像素
  /*
  var add = 0, min = 25
  for (var x13 = 225, y13 = 200; add <= 50;) {
    if (add <= 25) {
      dot(x13 + add, y13 + add, "red")
      dot(x13 + add, y13 - add, "red")
    }
    add++
    if (add > 25) {
      dot(x13 + add, y13 + min, "red")
      dot(x13 + add, y13 - min, "red")
      min--
    }
  }
  不对劲，怎么不是圆，哦，圆非线性，再来：
  */
  var r = 50
  for (var x13 = -50; x13 <= 50; x13++) {
    var y_move = Math.sqrt(r * r - x13 * x13)
    dot(250 + x13, 200 + y_move, "yellow")
    dot(250 + x13, 200 - y_move, "yellow")
  }
  for (var y13 = -50; y13 <= 50; y13++) {
    var x_move = Math.sqrt(r * r - y13 * y13)
    dot(250 + x_move, 200 + y13, "yellow")
    dot(250 - x_move, 200 + y13, "yellow")
  }

  // * 一个半径为200像素
  var r = 200
  for (var x14 = -200; x14 <= 200; x14++) {
    var y_move = Math.sqrt(r * r - x14 * x14)
    dot(250 + x14, 200 + y_move, "blue")
    dot(250 + x14, 200 - y_move, "blue")
  }
  for (var y14 = -200; y14 <= 200; y14++) {
    var x_move = Math.sqrt(r * r - y14 * y14)
    dot(250 + x_move, 200 + y14, "blue")
    dot(250 - x_move, 200 + y14, "blue")
  }

  // 画一个实心的圆，半径至少为100像素(为了不被覆盖，代码放前面)

  // 画一个【大小位置都合适】的sin(x)的图像
  for (var x16 = 0, y16 = 350; x16 <= 500; x16++) {
    y16 = Math.sin(x16 / 20) * 15
    dot(x16, y16 + 300, "darkgreen")
  }

  // 画出rgb色彩空间的某一面（尺寸要大于100x100）
  for (var x17 = 0; x17 <= 256; x17++) {
    for (var y17 = 0; y17 <= 256; y17++) {
      dot(x17 + 200, y17 + 400, "rgb(" + x17 + "," + y17 + ",255)")
    }
  }
  // 将其每个点的坐标乘以一个矩阵（如(2,0,0,2)或(1,0.27得到新的位置，即绘制出被线性变换后的色彩空间某一面
  //       可以考虑如下几种矩阵：
  //          2 0
  //          0 2
  //          scaling，缩放变换
  //          ------
  //          1  0.27
  //          0  1
  //          shearing，剪切变换
  //          ------
  //          0.5    0.87
  //          -0.87  0.5
  //          rotation，旋转变换

  for (var x17 = 0; x17 < 256; x17++) {
    for (var y17 = 0; y17 < 256; y17++) {
      var x171 = x17 * 2
      var y171 = y17 * 2
      dot(x171 + 50, y171 + 700, "rgb(" + x17 + "," + y17 + ",255)")
      dot(x171 + 1 + 50, y171 + 700, "rgb(" + x17 + "," + y17 + ",255)")
      dot(x171 + 50, y171 + 1 + 700, "rgb(" + x17 + "," + y17 + ",255)")
      dot(x171 + 1 + 50, y171 + 1 + 700, "rgb(" + x17 + "," + y17 + ",255)")
    }
  }
  //  色域RGB256色，跟随循环变化，要填 计数器x，y的值 而非 x和y的位移值
  //  放大2倍后，原先只打一个点，现在需要打4个，所以x轴和y轴方向的打点次数都需要变为2倍

  for (var x17 = 0; x17 < 256; x17++) {
    for (var y17 = 0; y17 < 256; y17++) {
      var x171 = x17 * 0.5
      var y171 = y17 * 0.5
      dot(x171 + 50, y171 + 500, "rgb(" + x17 + "," + y17 + ",255)")
    }
  }
  // 缩放转换(2为放大，0.5为缩小)

  for (var x17 = 0; x17 < 256; x17++) {
    for (var y17 = 0; y17 < 256; y17++) {
      var x172 = x17
      var y172 = y17 + 0.27 * x17
      dot(x172 + 650, y172 + 450, "rgb(255," + x17 + "," + y17 + ")")
    }
  }// 剪切转换（y轴被拉伸倾斜）(由于所有y值都整体向下移动，所以不会出现镂空效果)

  for (var x17 = 0; x17 < 256; x17++) {
    for (var y17 = 0; y17 < 256; y17++) {
      var x173 = x17 * 0.5 + y17 * 0.87
      var y173 = -0.87 * x17 + 0.5 * y17
      dot(x173 + 600, y173 + 300, "rgb(" + x17 + "," + y17 + ",255)")
    }
  }//旋转变换，此时θ为60度，cosθ为0.5，sinθ约为0.87

  function rota(X, Y, θ, color) {
    let theta = Math.PI / 180 * θ

    for (var x = 0; x < 256; x++) {
      for (var y = 0; y < 256; y++) {
        var x1 = x * Math.floor(Math.cos(theta)) + y * (Math.sin(theta))
        var y1 = Math.floor(-Math.sin(theta)) * x + (Math.cos(theta) * y)
        dot(x1 + X, y1 + Y, "rgb(" + x1 + "," + y1 + ",255)")
      }
    }
  }
  rota(500, 400, 30)

  // 封装成函数并尝试代入30度
  // 注意到有镂空效果，这是由于x，y值计算后取整会导致某些点没有打上
  // 对坐标使用3次矩阵变换(倾斜变换)完成旋转（倾斜不出现打点镂空问题）

  function rota1(X, Y, θ, color) {
    let theta = Math.PI / 180 * θ

    for (let x = 0; x < 256; x++) {
      for (let y = 0; y < 256; y++) {
        let x1 = x
        let y1 = Math.floor(y - Math.tan(theta / 2) * x)

        let x2 = x1 + Math.floor(Math.sin(theta) * y1)
        let y2 = y1

        let x3 = x2
        let y3 = Math.floor(y2 - Math.tan(theta / 2) * x2)
        dot(x3 + X, y3 + Y, "rgb(" + x3 + ",255," + y3 + ")")
      }
    }
  }
  rota1(700, 1000, 45)

  // 2阶贝塞尔曲线
  let ax = 500
  let ay = 50
  let bx = 600
  let by = 250
  let cx = 800
  let cy = 200

  for (let i = 0; i <= 1; i += 0.001) {
    let x = (ax * (1 - i) + bx * i) * (1 - i) + (bx * (1 - i) + cx * i) * i
    let y = (ay * (1 - i) + by * i) * (1 - i) + (by * (1 - i) + cy * i) * i
    dot(x, y)
  }

  // 3阶贝塞尔曲线
  let dx = 900
  let dy = 50

  for (let i = 0; i <= 1; i += 0.001) {
    let x = (ax * (1 - i) + bx * i) * (1 - i) * (1 - i) + (bx * (1 - i) + cx * i) * i * (1 - i) + (cx * (1 - i) + dx * i) * i * i
    let y = (ay * (1 - i) + by * i) * (1 - i) * (1 - i) + (by * (1 - i) + cy * i) * i * (1 - i) + (cy * (1 - i) + dy * i) * i * i
    dot(x, y)
  }

</script>

</html>
